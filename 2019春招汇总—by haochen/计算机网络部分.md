一、**HTTP1.1  HTTP2.0  HTTP3.0**

​	HTTP1.0和HTTP1.1区别：

​	1. HTTP1.1协议中最重要的特性是长连接。HTTP1.1的长连接机制是通过请求头中keep-alive信息来控制的。HTTP1.0中默认请求的服务器返回没有keep-alive，但在HTTP1.0中，也可以在请求消息中包含Connection:keep-alive头域信息，如果服务器能识别，会在响应消息头域也返回Connection:keep-alive表示后面的文件请求可以复用之前的链接传输。但是在HTTP1.1中任何请求的报文头部域都会默认包含keep-alive

​	2. 在HTTP1.0中主要使用header里的If-Modified-Since,Expires来做为缓存判断的标准，HTTP1.1则引入了更多的缓存控制策略例如Entity tag，If-Unmodified-Since, If-Match, If-None-Match等更多可供选择的缓存头来控制缓存策略。

​	3. HTTP1.0中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，HTTP1.1则在请求头引入了range头域，它允许只请求资源的某个部分，即返回码是206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。

​	4.在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除。

​	5. 在HTTP1.0中认为每台服务器都绑定一个唯一的IP地址，因此，请求消息中的URL并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。HTTP1.1的请求消息和响应消息都应支持Host头域，且请求消息中如果没有Host头域会报告一个错误（400 Bad Request）。

​	二者现存的一些问题：

1. 上面提到过的，HTTP1.x在传输数据时，每次都需要重新建立连接，无疑增加了大量的延迟时间，特别是在移动端更为突出。

2.  HTTP1.x在传输数据时，所有传输的内容都是明文，客户端和服务器端都无法验证对方的身份，这在一定程度上无法保证数据的安全性。

3.  HTTP1.x在使用时，header里携带的内容过大，在一定程度上增加了传输的成本，并且每次请求header基本不怎么变化，尤其在移动端增加用户流量。

4.  虽然HTTP1.x支持了keep-alive，来弥补多次创建连接产生的延迟，但是keep-alive使用多了同样会给服务端带来大量的性能压力，并且对于单个文件被不断请求的服务(例如图片存放网站)，keep-alive可能会极大的影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

   HTTP2.0 改进：

- **新的二进制格式**（Binary Format），HTTP1.x的解析是基于文本。基于文本协议的格式解析存在天然缺陷，文本的表现形式有多样性，要做到健壮性考虑的场景必然很多，二进制则不同，只认0和1的组合。基于这种考虑HTTP2.0的协议解析决定采用二进制格式，实现方便且健壮。
- **多路复用**（MultiPlexing），即连接共享，即每一个request都是是用作连接共享机制的。一个request对应一个id，这样一个连接上可以有多个request，每个连接的request可以随机的混杂在一起，接收方可以根据request的 id将request再归属到各自不同的服务端请求里面。

- **header压缩，**如上文中所言，对前面提到过HTTP1.x的header带有大量信息，而且每次都要重复发送，HTTP2.0使用encoder来减少需要传输的header大小，通讯双方各自cache一份header fields表，既避免了重复header的传输，又减小了需要传输的大小。

- **服务端推送**（server push），同SPDY一样，HTTP2.0也具有server push功能。目前，有大多数网站已经启用HTTP2.0。在HTML文档下载之前让HTML的JavaScript或者CSS文件先行下载，缩短页面加载渲染时间。

  HTTP2.0多路复用：

  ​	多路复用，就是在一个 TCP 连接中可以存在多条流。换句话说，也就是可以发送多个请求，对端可以通过帧中的标识知道属于哪个请求。通过这个技术，可以避免 HTTP 旧版本中的队头阻塞问题，极大的提高传输性能。在`HTTP1.1`的协议中，我们传输的`request`和`response`都是基本于文本的，这样就会引发一个问题：所有的数据必须按顺序传输`HTTP/2`引入`二进制数据帧`和`流`的概念，其中帧对数据进行顺序标识，这样浏览器收到数据之后，就可以按照序列对数据进行合并，而不会出现合并后数据错乱的情况。同样是因为有了序列，服务器就可以并行的传输数据，这就是`流`所做的事情。`HTTP/2`对同一域名下所有请求都是基于`流`，也就是说同一域名不管访问多少文件，也只**建立一路连接**。参考链接：https://segmentfault.com/a/1190000011172823

  HTTP 3.0

  基于 UDP 协议的 QUIC 协议，并且使用在了 HTTP/3 上，当然 HTTP/3 之前名为 HTTP-over-QUIC

  ### QUIC特性：

  1.多路复用： 传输的单个数据流可以保证有序交付且不会影响其他的数据流

  2.通过使用类似 TCP 快速打开的技术，缓存当前会话的上下文，在下次恢复会话的时候，只需要将之前的缓存传递给服务端验证通过就可以进行传输了。

  3.纠错机制：当出现其中的非校验包丢包的情况时，可以通过另外三个包计算出丢失的数据包的内容。当然这种技术只能使用在丢失一个包的情况下，如果出现丢失多个包就不能使用纠错机制了，只能使用重传的方式了。

二、**为什么 TCP 建立连接需要三次握手，明明两次就可以建立起连接**

​	三次握手的目的是“为了防止已经失效的连接请求报文段突然又传到服务端，因而产生错误”，这种情况是：一端(client)A发出去的第一个连接请求报文并没有丢失，而是因为某些未知的原因在某个网络节点上发生滞留，导致延迟到连接释放以后的某个时间才到达另一端(server)B。本来这是一个早已失效的报文段，但是B收到此失效的报文之后，会误认为是A再次发出的一个新的连接请求，于是B端就向A又发出确认报文，表示同意建立连接。如果不采用“三次握手”，那么只要B端发出确认报文就会认为新的连接已经建立了，但是A端并没有发出建立连接的请求，因此不会去向B端发送数据，B端没有收到数据就会一直等待，这样B端就会白白浪费掉很多资源。如果采用“三次握手”的话就不会出现这种情况，B端收到一个过时失效的报文段之后，向A端发出确认，此时A并没有要求建立连接，所以就不会向B端发送确认，这个时候B端也能够知道连接没有建立。

三、**请谈谈web的强缓存和协议缓存**

web缓存可以用以下这个图来表示：

![1552631788335](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1552631788335.png)

​	在浏览器第一次请求发生之后，再次进行请求的时候：

​	浏览器在请求某一资源，首先会先获取资源缓存的header信息，判断是否命中缓存（cache-control和expires）。若命中缓存则会直接从缓存中获取信息，包括header信息。那么这次请求就不会向服务器进行通信。

​	如果没有命中缓存，那么浏览器就会向服务器发送一个请求，在这个请求的header字段会携带第一次请求的有关字段信息（Last-Modified/If-Modified-Since和Etag/If-None-Match）。由服务器根据请求header来决定是否命中协议缓存。如果命中，就会返回新的header头，但是不会返回资源的内容。会告诉浏览器直接从缓存中取，否则就会返回最近的资源。

​	![1552632593335](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1552632593335.png)

协议缓存是由浏览器来决定缓存是否可用，在第一次请求的响应头中会带上某个字段（**Last-Modified或者Etag**）。后续请求的时候会带上对应的请求字段（**If-Modified-Since或者If-None-Match**），**若响应头没有Last-Modified或者Etag字段，则请求头也不会有对应的字段**

###### 你可能会觉得使用Last-Modified已经足以让浏览器知道本地的缓存副本是否足够新，为什么还需要Etag呢？HTTP1.1中Etag的出现主要是为了解决几个Last-Modified比较难解决的问题：

- 一些文件也许会周期性的更改，但是他的内容并不改变(仅仅改变的修改时间)，这个时候我们并不希望客户端认为这个文件被修改了，而重新GET；
- 某些文件修改非常频繁，比如在秒以下的时间内进行修改，(比方说1s内修改了N次)，If-Modified-Since能检查到的粒度是s级的，这种修改无法判断(或者说UNIX记录MTIME只能精确到秒)；
- 某些服务器不能精确的得到文件的最后修改时间。

这时，利用Etag能够更加准确的控制缓存，因为Etag是服务器自动生成或者由开发者生成的对应资源在服务器端的唯一标识符。

**Last-Modified**与ETag是可以一起使用的，服务器会优先验证ETag，一致的情况下，才会继续比对Last-Modified，最后才决定是否返回304。

用户行为对缓存的影响：

![1552633432201](C:\Users\lenovo\AppData\Roaming\Typora\typora-user-images\1552633432201.png)

四、**谈谈socket和webSocket**

首先二者虽然名字相似，但是功能和性质相差甚远。。

1.**socket**

socket其实有很多种意思，在IT行业的意思基本上就是在端到端的一个链接中，这两个端都叫做socket。往往指的是TCP/IP网络中两个链接端间的，大多数的IT从业者会提供基于这种概念的接口。在操作系统中也有socket的概念，但是这个socket就不是网络层面上的了。通常用来表示进程间的通信，代表了传输数据的两方，值得是操作系统的文件本身。

socket作为一种抽象层，应用程序通过它来发送和接收数据，使用socket可以将应用程序与处于同一网络中的其他应用程序进行通信交互。简而言之，socket提供了应用程序内部与外界通信的端口以及为通信双方提供了数据传输的通道。socket不是协议，他是在程序层面上对传输层的一个接口的封装。

2.**websocket**

首先，客户端发起http请求，经过3次握手后，建立起TCP连接；http请求里存放WebSocket支持的版本号等信息，如：Upgrade、Connection、WebSocket-Version等；
然后，服务器收到客户端的握手请求后，同样采用HTTP协议回馈数据；
最后，客户端收到连接成功的消息后，开始借助于TCP传输信道进行全双工通信。

五、**说说catch-control和Expires**

Expires = 时间，HTTP 1.0 版本，缓存的载止时间，允许客户端在这个时间之前不去检查（发请求）
max-age = 秒，HTTP 1.1版本，资源在本地缓存多少秒。
如果max-age和Expires同时存在，则被Cache-Control的max-age覆盖。Expires 的一个缺点就是，返回的到期时间是服务器端的时间，这样存在一个问题，如果客户端的时间与服务器的时间相差很大，那么误差就很大，所以在HTTP 1.1版开始，使用Cache-Control: max-age=秒替代。

六、**mysql语句优化**

- 合理建立索引
- 避免多次连接查询和嵌套查询
- 避免数据类型不一致
- 禁止不必要的ORDER BY排序
- 批量INSERT插入可以合并插入

七、**TCP连接过程**

1. 客户端发送一个SYN给服务器，表示想连接。
2. 服务器发送SYN和ACK给客户端，表示接受到你的请求了，并且同意连接。
3. 然后客户端发送ACK给服务器，表示收到并且连接。

八、**TCP四次挥手**

1. 客户端发送一个FIN报文给服务器，表示我将关闭客户端到服务器端这个方向的连接。
2. 服务器收到报文后，发送一个ACK报文给客户端。
3. 服务器发送一个FIN报文给客户端，表示自己也将关闭服务器端到客户端这个方向的连接。
4. 客户端收到FIN后，发回一个ACK报文给服务器，FIN的序号加1。

九、**websocket和http的异同**

相同点：

1. 都是一样基于TCP的，都是可靠性传输协议。
2. 都是应用层协议。

不同点：

  1. WebSocket是双向通信协议，模拟Socket协议，可以双向发送或接受信息。HTTP是单向的。
  2. WebSocket是需要浏览器和服务器握手进行建立连接的。而http是浏览器发起向服务器的连接，服务器预先并不知道这个连接。

联系：

WebSocket在建立握手时，数据是通过HTTP传输的。但是建立之后，在真正传输时候是不需要HTTP协议的。

